(ns stackfn-sandbox.stack.vm
  (:require
   [stackfn-sandbox.stack.interpret-node :as interpret-node])
  (:import
   (java.util UUID)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; States

(def init-state
  {:pc 0 :instrs [] :stack [] :env {}})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Spy support

(defn- notify-spies [watched-atom run-id new-state]
  (swap! watched-atom
         (fn [run-states]
           (if (= :done new-state)
             (-> run-states
                 (update :done conj run-id))
             (-> run-states
                 (update-in [:run-states-table run-id]
                            (fn [states]
                              (if states
                                (conj states new-state)
                                [new-state]))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Interpreter loop

(declare ^:dynamic *spy*)

(def max-stack-depth (* 1024 1000))

(defn interpreter-loop [state]
  (let [run-id (UUID/randomUUID)]
    (try
      (loop [{:keys [pc instrs stack env] :as state} state]
        (when *spy* (notify-spies *spy* run-id state))
        (when (< max-stack-depth (count stack))
          (throw (ex-info "Exceeded max stack depth"
                          {:pc pc
                           :stack-depth (count stack)
                           :max-stack-depth max-stack-depth})))

        (cond (= pc (count instrs))
              (peek stack)

              (or (> pc (count instrs))
                  (< pc 0))
              (throw (ex-info "Corrupt interpreter state"
                              {:pc pc}))

              :else
              (let [state-xformer (interpret-node/interpret-node (get instrs pc))
                    state-new (state-xformer state)]
                (recur state-new))))
      (finally
        (when *spy* (notify-spies *spy* run-id :done))))))

(defonce
  ^{:dynamic true
    :doc "Bind this to the reference generated by `(make-spy-reference)`.
Then any functions watching the reference can watch stackfns update state."}
  *spy* nil)

(defn make-spy-reference []
  (atom {:run-states-table {} :done #{}}))
